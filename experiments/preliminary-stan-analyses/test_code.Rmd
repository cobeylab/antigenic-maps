---
title: "Multi epitope code tests"
output: html_notebook
---

Write a series of tests to make sure the multi epitope code is doing what we expect

```{r}
source('multi_epitope_code.R')
source('../code.R')
reset() ## clear workspace and load packages


n_dim = 2
n_ag = 5
n_ab = 0
n_chains = 4
n_iter = 5000 # half will be burn in
```


---------------------------------------------------------------


## 0.1. Does code run when there's only one Ab per epitope?


Generate ag coords

```{r}
n_epitopes = 3
antigen_coords <- tibble(epitope = rep(c(1:n_epitopes), each = n_ag),
                         antigen = rep(1:n_ag, n_epitopes),
                         kind = 'antigen',
                         c1 = generate_ag_coords_random(n_ag, n_epitopes),
                         c2 = generate_ag_coords_random(n_ag, n_epitopes)) %>%
  mutate(epitope = as.factor(epitope),
         antigen = as.factor(antigen))
```

Plot ag coords
```{r}
plot_antigen_coords(antigen_coords)
```

Infer maps
```{r, echo=F, include=F}
oneAb_per_epitope <- infer_ferret_map(antigen_coords = antigen_coords, relative_concentrations = c(1,1,1), n_epitopes = 3, n_antigens = 5, n_abs_per_serum = 3, plotdir = 'test_1Ab_per_epitope')
```
Plot heatmap
```{r}
oneAb_per_epitope$titer_map %>%
  ggplot() +
  geom_tile(aes(x = serum, y = antigen, fill = titer_distance)) +
  scale_fill_viridis_c(direction =-1, option = 'B')
```

Compare inferred distances to actual distances between epitopes
```{r}

```

---------------------------------------------------------------

```{r}
## 0.2. Code runs where some epitopes have 0 immunodominance?
```



## 1. If there's only one epitope and if all Abs are exactly at the same position as the epitope, then we should recover the underlying map exactly

```{r}
antigen_coords <- tibble(epitope = rep(c(1:1), each = n_ag),
                         antigen = rep(1:n_ag, 1),
                         kind = 'antigen',
                         c1 = generate_ag_coords_random(n_ag, 1),
                         c2 = generate_ag_coords_random(n_ag, 1)) %>%
  mutate(epitope = as.factor(epitope),
         antigen = as.factor(antigen))

shifted_coords <-  standardize_coordinates(coord_mat = antigen_coords %>% select(starts_with('c')) %>% as.matrix(), ag1_row = 1, ag2_row = 2) %>%
  as_tibble() %>%
  set_names(c('c1', 'c2'))

antigen_coords$c1 = shifted_coords$c1
antigen_coords$c2 = shifted_coords$c2
```


Infer titer map
```{r echo=FALSE, include=FALSE}
one_epitope_no_ab_jitter <- infer_ferret_map(antigen_coords = antigen_coords, 
                                            relative_concentrations = c(1),
                                            n_epitopes = 1, 
                                            n_antigens = 5, 
                                            n_abs_per_serum = 10, 
                                            plotdir = 'test01_one_epitope_no_ab_jitter', sigma = 0.00001)
```


Plot ags and abs
```{r}
one_epitope_no_ab_jitter$ag_ab_coords %>%
 plot_Ab_Ag_map_v2(antigen_coords = antigen_coords)
  
```



View the inferred points.

--> This looks good. The inferred points are an exact match, or a reflection about the x axis.

```{r}
one_epitope_no_ab_jitter$inferred_map_plot +
  facet_wrap(.~chain)
```


---------------------------------------------------------------


## 2. If there's only one epitope and Abs are distributed around each, then we should recover the underlying map with minial error

Infer titer map
```{r echo=FALSE, include=FALSE}
one_epitope_no_ab_withjitter <- infer_ferret_map(antigen_coords = antigen_coords, 
                                            relative_concentrations = c(1),
                                            n_epitopes = 1, 
                                            n_antigens = 5, 
                                            n_abs_per_serum = 10, 
                                            plotdir = 'test02_one_epitope_no_ab_withjitter', 
                                            sigma = .1)
```


Plot ags and abs
```{r}
one_epitope_no_ab_withjitter$ag_ab_coords %>%
 plot_Ab_Ag_map(antigen_coords) +
facet_wrap(.~antigen, labeller = label_both)
  
```
--> Abs are extremely jittered and sparse...


View the inferred points.

--> This looks good. The inferred points are an exact match, or a reflection about the x axis.
```{r}
plot_inferred_original_map(antigen_coords, one_epitope_no_ab_withjitter$stan_fits)
  
```



---------------------------------------------------------------

## 3. If there's multiple epitopes, but all Abs are specific to one, then we should reproduce the outputs of #2.

```{r}
antigen_coords <- tibble(epitope = rep(c(1:3), each = n_ag),
                         antigen = rep(1:n_ag, 3),
                         kind = 'antigen',
                         c1 = generate_ag_coords_random(n_ag, 3),
                         c2 = generate_ag_coords_random(n_ag, 3)) %>%
  mutate(epitope = as.factor(epitope),
         antigen = as.factor(antigen))

shifted_coords <-  standardize_coordinates(coord_mat = antigen_coords %>% select(starts_with('c')) %>% as.matrix(), ag1_row = 1, ag2_row = 2) %>%
  as_tibble() %>%
  set_names(c('c1', 'c2'))

antigen_coords$c1 = shifted_coords$c1
antigen_coords$c2 = shifted_coords$c2
```


```{r}
plot_antigen_coords(antigen_coords)
```

Infer titer map
```{r, echo=F, include=F}
three_epitopes_e1dominant <- infer_titer_map(antigen_coords, 
                relative_concentrations = c(3, 0, 0), 
                n_epitopes = 3, 
                n_antigens = 5, 
                n_abs_per_serum = 500, 
                plotdir = 'test03_3epitopes_E1dominant', 
                sigma = .1)
```


Plot ags and abs
```{r}
three_epitopes_e1dominant$ag_ab_df %>%
 plot_Ab_Ag_map() +
facet_wrap(.~antigen, labeller = label_both)
  
```


View the inferred points.

Initially, when sigma was 1: I'm not sure why the inferred points don't exactly match the underlying E1 points. Let's dig in.
After changing sigma to 0.1: Ok, this looks very sensible.
When we increase the number of Abs to 500 this looks extra good.

```{r}
three_epitopes_e1dominant$inferred_map_plot +
  facet_wrap(.~chain)
```
When sigma =1, the Abs are too dispersed for accurate inference.
I changed sigma=0.1 and now things look good.

```{r}
three_epitopes_e1dominant$ag_ab_df %>%
  ggplot() +
  geom_point(aes(x = c1_Ag, y = c2_Ag, shape = epitope)) +
  geom_point(aes(x = c1, y = c2, color = epitope), data = antigen_coords) +
  geom_point(aes(x = c1_Ab, y = c2_Ab, color = epitope), pch = 3)
```
---------------------------------------------------------------



## 4. If only one epitope mutates, the magnitude of titer differences should increase as that epitope becomes more immunodmoinant

```{r}
coords_one_mutates = antigen_coords %>%
  mutate(c1 = ifelse(epitope==1, c1, 0),
         c2 = ifelse(epitope==1, c2, 0))

coords_one_mutates %>%
  ggplot() +
  geom_point(aes(x = jitter(c1), y = jitter(c2), col = epitope, shape = antigen))
```



```{r, echo=F, include=F}
equally_immunodominant <- infer_titer_map(coords_one_mutates, 
                relative_concentrations = c(1,1,1), 
                n_epitopes = 3, 
                n_antigens = 5, 
                n_abs_per_serum = 100, 
                plotdir = 'test4.1_equally_immunodominnat', 
                sigma = .1)
```

```{r, echo=F, include=F}
skewed_immunodominance <- infer_titer_map(coords_one_mutates, 
                relative_concentrations = c(1+2/3, 1, 1/3), 
                n_epitopes = 3, 
                n_antigens = 5, 
                n_abs_per_serum = 100, 
                plotdir = 'test4.2_skewed_immunodominnance', 
                sigma = .1)
```


```{r, echo=F, include=F}
complete_immunodominance <- infer_titer_map(coords_one_mutates, 
                relative_concentrations = c(3, 0, 0), 
                n_epitopes = 3, 
                n_antigens = 5, 
                n_abs_per_serum = 100, 
                plotdir = 'test4.3_complete_immunodominnance', 
                sigma = .1)
```


```{r}
cowplot::plot_grid(equally_immunodominant$inferred_map_plot + ggtitle('even') + theme(legend.position = 'none') + facet_wrap(.~chain),
                   skewed_immunodominance$inferred_map_plot + ggtitle('skewed') + theme(legend.position = 'none') + facet_wrap(.~chain),
                   complete_immunodominance$inferred_map_plot+ ggtitle('all or nothing') + theme(legend.position = 'none') + facet_wrap(.~chain),
                   cowplot::get_legend(equally_immunodominant$inferred_map_plot)
                   )
```



## Compare titer maps under three schemes

```{r}

bind_rows(
  list(
  equal = equally_immunodominant$titer_map,
  skewed = skewed_immunodominance$titer_map,
  all_or_nothing = complete_immunodominance$titer_map
  ),
.id = 'immunodominance_scheme') %>%
  ggplot()+
  geom_tile(aes(x = serum, y = antigen, fill = titer_distance)) +
  scale_fill_viridis_c(direction = -1, option = 'B') +
  facet_wrap(.~immunodominance_scheme)
```

This looks good. The equal map has the least changes. The skewed map has intermediate chances in titer, and the all_or_nothing map has the greatest changes.

