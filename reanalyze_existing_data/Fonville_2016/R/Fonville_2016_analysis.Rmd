---
title: "Fonville 2016 reanalysis"
output: html_notebook
---
```{r include=FALSE}
rm(list = ls())
library(ggplot2)
library(tidyr)
library(dplyr)
filter <- dplyr::filter
source('analysis_funs.R')
```

## Import ferret titer data

## Sera and strain panels differ. Ugs. ID homologous pairs tomorrow.

```{r}
ferret_titers = import_ferret_titers()
```

## Import ferret distances

```{r}
ferret_distances = import_map_distances()
```


## Import human titer data
```{r}
child_titers = import_human_titer_data()
```

## Identify homologous strains

```{r}
individual_distances <- import_human_titer_data() %>%
  group_by(subject, season, age_mos) %>%
  extract(season, into = 'season_y1', regex = '(\\d\\d\\d\\d)/\\d+', convert = T, remove = F) %>% # Extract first year of season in which sample was collected
  mutate(earliest_possible_YOB = season_y1 - ceiling(age_mos/12),
         latest_possible_YO_sample = season_y1 + 2,
         circulated_in_infection_window = strain_year >= earliest_possible_YOB & strain_year <= latest_possible_YO_sample,
         max_titer_strain = ifelse(titer == max(titer), strain, NA),
         putative_primary_strain = ifelse(strain %in% get_putative_primary_strains(strain, titer, circulated_in_infection_window), as.character(strain), NA),
         subject_label = get_subject_factor_by_YOB(subject, earliest_possible_YOB, season),
         xval = jitter(strain_year),
         homologous_titer = max(logtiter[circulated_in_infection_window]),
         individual_distance = homologous_titer - logtiter) %>%
  ungroup()
```

```{r}
individual_distances %>%
   mutate(undetectable_titers = ifelse(logtiter<0, logtiter, NA)) %>%
   mutate(ribbon_vals = ifelse(circulated_in_infection_window, strain_year, NA)) %>%
  ggplot() +
#  geom_vline(aes(xintercept = earliest_possible_YOB), color = 'dodgerblue')+
#  geom_vline(aes(xintercept = latest_possible_YO_sample), color = 'dodgerblue')+
  facet_wrap(.~subject_label, ncol = 4) +
  geom_ribbon(aes(x = ribbon_vals, ymin = -1, ymax = 15), fill = 'gray', alpha = .5) +
  geom_point(aes(x = xval, y = logtiter, color = circulated_in_infection_window)) +
  geom_point(aes(x = xval, y = undetectable_titers), color = 'gray') +
  geom_point(aes(x = xval, y = logtiter), pch = 4, data = individual_distances %>% filter(!is.na(putative_primary_strain))) +
  geom_text(aes(x = xval+3, y = logtiter+4, label = strain), angle = 50, data = individual_distances %>% filter(!is.na(putative_primary_strain)), size = 2.5) +
  theme(legend.position = c(.75, 0.05)) +
  xlab('Year of strain isolation') +
 # ylim(c(0, 12))+
  theme(axis.text.x = element_text(angle = 35, hjust = 1))
ggsave('../plots/subject_titers.png', width = 9, height = 7, units = 'in', dpi = 300)
```






Figure legend: Each subject's logtiter to all strains in the panel. The blue lines demarcate the infection window - the left line is the earliest possible year of birth, and the right line is the latest possible calendar year of sampling, based on the reported sample season, and the subject's age in months at the time of sampling. Putative primary strains, defined as the strain(s) in the infection window to which the subject shows the highest logtiter, are marked with a black x and named.

Observations:

* In many, but not all subjects, the highest titer is to a strain in the infection window.
* In some subjects, there are two putative homologous strains. 


## Which strains should be considered homologous?

I propose this definition:

1. Individual distance = $s_{max}-s_j$, where $s_max$ is the maximum log titer to any strain that circulated in the sampling window, and $s_j$ is the logtiter to the test strain



## Compare individual to ferret distances
```{r}
# To calculate individual distances:
#   
# 1. ID each possible primary strain
# 2. For each possible primary strain, extract pairwise distanes
# 3. Merge the pairwise distances

merged_distances = individual_distances %>%
  group_by(subject, putative_primary_strain) %>%
  filter(!is.na(putative_primary_strain)) %>%
  summarise() %>%
  distinct() %>%
  ungroup() %>% ## Get a df of subjects and primary starins
merge(  ## Merge with the ferret distances from each primary strain to all other strains
  ferret_distances %>%
    rename(putative_primary_strain = strain1,
           strain = strain2,
           ferret_map_distance = distance),
  all.y = T
) %>%
  merge(individual_distances %>% select(-putative_primary_strain)) %>%
  mutate(strain = factor(strain, levels = get_strains_chronologically(strain, strain_year))) %>%
  ungroup() %>% group_by(subject) %>%
  mutate(primary_strain_id = as.numeric(factor(putative_primary_strain)),
         x_dodge = as.numeric(strain) + (primary_strain_id-mean(primary_strain_id))*.2) %>%
  ungroup() %>%
  group_by(putative_primary_strain) %>%
  mutate(primary_strain_year = extract_strain_year(putative_primary_strain)) %>%
  mutate(temporal_distance = abs(primary_strain_year - strain_year)) %>%
  mutate(ferret_overestimate = ferret_map_distance - individual_distance) 
```



```{r}
merged_distances %>%
  filter(is_high_responder) %>%
  mutate(ribbon_vals = ifelse(circulated_in_infection_window, as.numeric(strain), NA),
         adjusted_ferret_distance = adjust_ferret_distances(ferret_map_distance),
         expected_logtiter_ferret_distance = homologous_titer - ferret_map_distance,
         expected_logtiter_adjusted_distance = homologous_titer - adjusted_ferret_distance,
         is_undetectable = ifelse(logtiter<0, logtiter, NA)) %>%
  ggplot() +
  geom_point(aes(x = strain, y = logtiter), color = NA) +
  geom_ribbon(aes(x = x_dodge, ymin = -10, ymax = 0), fill = 'gray', alpha = .5) +
  geom_ribbon(aes(x = ribbon_vals, ymin = -10, ymax = 8), fill = 'aquamarine', alpha = .5) +
  geom_hline(aes(yintercept = 0), lty = 3)+
  geom_hline(aes(yintercept = homologous_titer), lty = 2)+
  geom_vline(aes(xintercept = putative_primary_strain), lty = 3)+
  geom_segment(aes(x = x_dodge, xend = x_dodge, y = homologous_titer, yend = logtiter), lty = 1) +
  geom_segment(aes(x = x_dodge, xend = x_dodge, y = logtiter, yend = expected_logtiter_ferret_distance), color = 'firebrick2', lty = 2) +
  geom_point(aes(x = x_dodge, y = logtiter)) +
    geom_point(aes(x = x_dodge, y = is_undetectable), pch = 23, fill = 'gray') +
  geom_segment(aes(x = x_dodge-.2, xend = x_dodge+.2, y = expected_logtiter_ferret_distance, yend = expected_logtiter_ferret_distance), color = 'firebrick2') +
 # geom_segment(aes(x = x_dodge-.2, xend = x_dodge+.2, y = expected_logtiter_adjusted_distance, yend = expected_logtiter_adjusted_distance), color = 'deepskyblue') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  facet_wrap(.~subject_label) +
  ylab('distance from primary strain') +
  ggtitle('High responders')
ggsave('../plots/high_responder_comparison.png', width = 9, height = 5, dpi = 300, units = 'in')
```


```{r}
merged_distances %>%
  filter(!is_high_responder) %>%
  mutate(ribbon_vals = ifelse(circulated_in_infection_window, as.numeric(strain), NA),
         ferret_higher = ferret_map_distance >= individual_distance,
         adjusted_ferret_distance = adjust_ferret_distances(ferret_map_distance)) %>%
  ggplot() +
  geom_point(aes(x = strain, y = individual_distance), color = NA) +
  geom_ribbon(aes(x = ribbon_vals, ymin = -1, ymax = 16), fill = 'gray', alpha = .5) +
  geom_hline(aes(yintercept = 0), lty = 3)+
  geom_vline(aes(xintercept = putative_primary_strain), lty = 3)+
  geom_segment(aes(x = x_dodge, xend = x_dodge, y = ferret_map_distance, yend = individual_distance, color = ferret_higher), lty = 2) +
  geom_point(aes(x = x_dodge, y = individual_distance)) +
  geom_segment(aes(x = x_dodge-.2, xend = x_dodge+.2, y = ferret_map_distance, yend = ferret_map_distance)) +
 # geom_point(aes(x = x_dodge, y = adjusted_ferret_distance), color = 'yellowgreen')+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  facet_wrap(.~subject_label) +
  ylab('distance from primary strain') +
  ggtitle('Low responders')
ggsave('../plots/low_responder_comparison.png', width = 9, height = 5, dpi = 300, units = 'in')
```


## Can we use a linear model to represent these residuals?

```{r}
ferret_distance_fit = lm(ferret_overestimate~0+ferret_map_distance, data = merged_distances)
summary(ferret_distance_fit)
AIC(ferret_distance_fit)
```

```{r}
ferret_distance_fit_grouped = lm(ferret_overestimate~0+ferret_map_distance*is_high_responder, data = merged_distances)
summary(ferret_distance_fit_grouped)
AIC(ferret_distance_fit_grouped)
```


```{r}
temporal_distance_fit = lm(ferret_overestimate~0+temporal_distance, data = merged_distances)
summary(temporal_distance_fit)
AIC(temporal_distance_fit)
```

```{r}
temporal_distance_fit_grouped = lm(ferret_overestimate~0+temporal_distance*is_high_responder, data = merged_distances)
summary(temporal_distance_fit)
AIC(temporal_distance_fit)
```

## Both the grouped models are significantly better fit to data

```{r}
anova(ferret_distance_fit_grouped, ferret_distance_fit)
anova(temporal_distance_fit_grouped, temporal_distance_fit)
```

## Compare models

The ferret_distance model with separate slopes for high and low responders is the best AIC

But the high/low responder grouping is not generalizable, so we'll just take the overall fit 

```{r}
tibble(model = c('temporal_distance', 'temporal_distance_grouped', 'ferret_distance', 'ferret_distance_grouped'),
       AIC = c(AIC(temporal_distance_fit), AIC(temporal_distance_fit_grouped), AIC(ferret_distance_fit), AIC(ferret_distance_fit_grouped))) %>%
  mutate(del_AIC = AIC-min(AIC)) %>%
  arrange(del_AIC)
```
## Save the best fit
```{r}
write_rds(x = ferret_distance_fit, '../processed_data/primary_ferret_human_distance_lm.rds')
```


## The ferret distance model is better -- it has a lower AIC

```{r}
merged_distances %>%
  ggplot(aes(x = ferret_map_distance, y = ferret_overestimate)) +
  geom_point(alpha = .5) 
ggsave('../plots/regression_fit_0.png')
```


```{r}
merged_distances %>%
  ggplot(aes(x = ferret_map_distance, y = ferret_overestimate)) +
  geom_point(alpha = .5) +
  geom_smooth(method = lm, formula = 'y~0+x', se = TRUE)
ggsave('../plots/regression_fit.png')
```

```{r}
merged_distances %>%
  ggplot(aes(x = temporal_distance, y = ferret_overestimate)) +
  geom_point(alpha = .5) +
  geom_smooth(method = lm, formula = 'y~0+x', se = TRUE)
```





