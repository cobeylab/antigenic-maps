---
title: "Bayesian MDS in Stan"
output: html_notebook
---

Write and test a Stan model

```{r}
generate_alleles <- function(ndim, nalleles, range = 10){
  # Randomly draw coordinates in each dimension
  sapply(1:ndim, function(dim){runif(nalleles, -range/2, range)}) %>%
    as.tibble() %>%
    set_names(paste0('c', 1:ndim)) %>%
    # Assign allele ids
    mutate(allele = 1:nalleles)
}
```

```{r}
## Generate coordinates for a separate set of antigens (Ag) and sera (Ab)
ab_ag_coordinates <- generate_alleles(2, 10) %>%
  mutate(kind = rep(c('Ag', 'Ab'), each = 5))

ab_ag_coordinates %>%
  ggplot(aes(x = c1, y = c2, color = kind)) +
  geom_point()
```

```{r}
## Calculate the distance matrix
distmat <- dist(as.matrix(ab_ag_coordinates %>% select(starts_with('c'))), diag = T) %>%
  as.matrix()
## Keep only Ag - Ab pairs
ag_indices = ab_ag_coordinates$kind == 'Ag'
ab_indices = ab_ag_coordinates$kind == 'Ab'
observed_distmat = distmat[ag_indices, ab_indices]
observed_distmat
```

## Infer map using basic stan model


To get this working, let's initalize using the exact solution 
```{r}
  initfun <- function(){
    list(sigma = .05,
         strain_coords = (coords %>% filter(kind == 'antigen') %>% select(starts_with('c')) %>% as.matrix),
         serum_coords = (coords %>% filter(kind == 'serum') %>% select(starts_with('c')) %>% as.matrix)
         )
    }
```


```{r}
fit_stan_MDS <- function(
  mod = 'MDS.stan',
  observed_distances, # vector of delay for each individual in the data
  n_antigens,
  n_sera,
  n_dim,
  chains = 3, # Number of MCMC chains to run
  cores = parallel::detectCores(logical = F),
  ...
) {
  library(rstan)
  
  stopifnot(nrow(observed_distances) == n_antigens)
  stopifnot(ncol(observed_distances) == n_sera)
  
  model <- stan_model('../MDS.stan')
  
  model_input_data <- list(
    n_strains = n_antigens,
    n_sera = n_sera,
    n_dim = n_dim,
    observed_distances = observed_distances
  )
  
  fit <- sampling(
    model, model_input_data, chains = chains, cores = cores, 
    init = initfun,
    iter = 5000,
    control = list(adapt_delta = 0.8,
                    max_treedepth = 13),
    ...
  )
}

```

```{r}
fits <- fit_stan_MDS(observed_distances = observed_distmat, n_antigens = 5, n_sera = 5, n_dim = 2, chains = 2)
```

```{r}
fits_df <- as.data.frame(fits) %>%
  summarise_all(median) %>%
  select(-sigma, -lp__) %>%
  pivot_longer(everything(), names_to = c('kind', 'coord', 'id'), names_pattern = '(\\w+)_coords\\[(\\d),(\\d)\\]', values_to = 'value') %>%
  pivot_wider(names_from = coord, names_prefix = 'c') %>%
  select(c1, c2, id, kind)
```

## Transform to the standard basis:
```{r}
## Define function
solve_for_transition_to_standard_basis <- function(mds_coords, original_coords){
  loss_function <- function(pars, mds_coords, original_coords){
    v1 = pars['v1']
    v2 = pars['v2']
    u1 = pars['u1']
    u2 = pars['u2']
    
    Cprime = t(mds_coords)
    C = t(original_coords)
    
    transition_matrix = matrix(c(v1, v2, u1, u2), 2, 2)
    
    sqrt(sum(((transition_matrix %*% Cprime)-C)^2))
  }
  
  optim(par = c(v1 = 1, v2 = 2, u1 = 1, u2 = 2), fn = loss_function, mds_coords = mds_coords, original_coords = original_coords)
}


transform_to_standard_basis <- function(mds_coords, original_coords){
  original_coords = as.matrix(original_coords)
  transition_coords <- solve_for_transition_to_standard_basis(mds_coords, original_coords)
  transition_matrix <- matrix(transition_coords$par, 2, 2)
  transition_matrix %*% t(mds_coords) %>%
    t() %>%
    as.tibble() %>%
    # Vertical and horizontal shift to re-center
    mutate(V1 = V1 - mean(V1) + mean(original_coords[,1]),
           V2 = V2 - mean(V2) + mean(original_coords[,2])) %>%
    set_names(paste0('c', 1:2)) %>%
    mutate(id = 1:n())
}
```

```{r}
## Apply function
transformed_mds <- transform_to_standard_basis(mds_coords = fits_df %>% select(starts_with('c')) %>% as.matrix(), 
                            original_coords = ab_ag_coordinates%>% select(starts_with('c')) %>% as.matrix()) %>%
  mutate(kind = rep(c('strain', 'serum'), each = 5))
```




## Visualize fits using mean estimate for each coord
```{r}
bind_rows(list('raw_mds' = fits_df %>% mutate(id = as.numeric(id)), 
              'actual' = ab_ag_coordinates %>% rename(id = allele),
              'transformed_mds' = transformed_mds %>% select(c1, c2, id, kind)
          ),
          .id = 'source') %>%
  ggplot() +
  geom_point(aes(x = c1, y = c2, color = kind, shape = source))
```


--> This isn't really working. I'm not sure if it's a problem with the model or a mean/median posterior thing.
