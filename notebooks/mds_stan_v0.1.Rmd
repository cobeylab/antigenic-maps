---
title: "Bayesian MDS in Stan"
output: html_notebook
date: 01/26/2022
---

## Summary:

* The stan.mds model is working! In that it correctly infers the map, preserving the original distances between Ab and Ag.
* But, the stan.mds model is currently inferring a map that is an isometry of the original coordinates. E.g. the inferred map is rotated, reflected, and shifted relative to the original coordinates. Sometimes the shift is SUBSTANCIAL (e.g. 100 units on the x or y axis.) This makes it difficult to:

  * Compare the inferred coordinates to the true coordinates.
  * Assess convergencve (because different chains converge to different isometries. Ugh.)
  
NEXT STEPS:

* Try to constrain the inference to a single isometry:

  * Fix the coordinates of Ag 1 to the origin
  * Fix the direction of the vector (Ag1-Ag2) parallel to axis 1. In other words, the coordinates of Ag2 will be: (x, 0, 0, ...), where x is a free parameter, and the coordinates in all other dimensions are 0.
  * These constraints are arbitrary and will not affect inference.
  * It will still be possible to infer isometric reflections about axis 1 (in 2D), or rotations about axis 1 (in 3D), or more complicated transformations of the original map in higher dimensions. But these constraints will make it easier to assess convergence, and to do post-hoc tranformations of the inferred coordinates.

Write and test a Stan model

```{r setup, include=FALSE}
rm(list = ls())
library(tidyr)
filter <- dplyr::filter
extract <- tidyr::extract
select <- dplyr::select
source('../code.R')
```


```{r cars}
n_antigens = 5
n_sera = 6
n_dim = 3
coords <- generate_map_coordinates(n_dim = n_dim, 
                                   n_antigens = n_antigens, 
                                   n_sera = n_sera, 
                                   map_range = c(-10, 10))
coords
```

## Plot the synthetic coordinates
```{r}
original_coord_plot <- coords %>%
  ggplot() +
  geom_point(aes(x = c1, y = c2, color = kind))
```

## Get the distances between coordinates

* We only observe the distances between antigen (ag) and antibody/serum (ab), not between ag-ag or ab-ab.
* Assume all ag-ab distances are observed without error

```{r}
# Like most of the functions in thei script, `get_ab_ag_distances` is a function defined in `../code.R`
distmat <- get_ab_ag_distances(ab_coords = filter(coords, kind == 'serum') %>% coord_tibble_to_matrix(),
                               ag_coords = filter(coords, kind == 'antigen') %>% coord_tibble_to_matrix())
```

## Transform the coordinates so that ag1 is at the origin, and ag2 falls on axis 1:
```{r}
standardize_coordinates <- function(coord_mat, 
                                    ag1_row = 1,
                                    ag2_row = 2
){
  n_dim = ncol(coord_mat) 
  stopifnot(nrow(coord_mat) >= n_dim)
  
  ## Shift the whole matrix so that ag1 is at the origin.
  shifted = shift_to_origin(coord_mat, origin_row = ag1_row)
  cat('shifted cords\n')
  print(shifted)
  
 # plot_ly(x=shifted[,1], y=shifted[,2], z=shifted[,3], type='scatter3d', mode='markers')
  
  ## The coordinates of the vector (ag1, ag2) are now the ag2 coordinates, because all ag1 coordinates are 0.
  ## We want to rotate the map so that ag2 falls on axis 1
  if(n_dim ==3){
    x_z_projection_vec = c(shifted[ag2_row, 1], 0, shifted[ag2_row, 3])
    theta = pi-get_theta(v1 = c(1,0,0), v2 = x_z_projection_vec)
    theta = ifelse(shifted[ag2_row, 3]<0, 2*pi-theta, theta) ## If y is negative, then we need to rotate in the opposite direction
    ## Rotate about the y axis to align ag2 with the x-y plane
    rotated_matrix = rotate_about_y_axis_3d(theta = 2*pi-theta, coords = shifted)
    rotated_matrix
   # plot_ly(x=shifted[,1], y=shifted[,2], z=shifted[,3], type='scatter3d', mode='markers')
    
    # Check that the first row has coordinates (0,0,0) and the second row (x,0,0)
    cat('\n rotated coords:\n')
    print(rotated_matrix)
    # Check that distances are preserved
    cat('\noriginal distances:/n')
    print(distmat)
    cat('\n rotated:\n')
    print(get_ab_ag_distances(ab_coords = rotated_matrix[6:11,], ag_coords = rotated_matrix[1:5,]))
    
    ## Rotate about the z-axis to align ag2 with the x axis, and return
    theta2 = pi-get_theta(c(1,0,0), rotated_matrix[2,])
    theta2 = ifelse(rotated_matrix[2,1]<0, 2*pi-theta2, theta2)
    final_output = rotate_about_z_axis_3d(theta = theta2, 
                       coords = rotated_matrix)
    
  }else if(n_dim == 2){
    ## Rotate about the origin to align with x and return
    theta = get_theta(shifted[ag2_row,], c(1,0))
    final_output = rotate_by_theta_2d(theta = theta, 
                       coords = shifted)
    
    # plot(coord_mat, ylim = c(-20, 20), xlim = c(-20, 20))
    # points(shifted, col = 'red')
    # segments(0, 0, x1 = shifted[2,1], y1 = shifted[2,2], col = 'red')
    # points(rotated, col = 'orange', pch = 16)
    # segments(0, 0, x1 = rotated[2,1], y1 = rotated[2,2], col = 'orange')
  }else{
    stop('standardization only implemented for 2d or 3d maps')
  }
  return(final_output)
}
```

## Test
```{r}
standardize_coordinates(coord_mat = coord_tibble_to_matrix(coords), 1, 2)
```





## Infer map using basic stan model


To get this working, let's initalize using the exact solution 
```{r}
  initfun <- function(){
    list(sigma = .05,
         strain_coords = (coords %>% filter(kind == 'antigen') %>% select(starts_with('c')) %>% as.matrix),
         serum_coords = (coords %>% filter(kind == 'serum') %>% select(starts_with('c')) %>% as.matrix)
         )
    }
```


```{r}
fit_stan_MDS <- function(
  mod = 'MDS.stan',
  observed_distances, # n_antigen x n_antibody matrix of distances
  n_antigens, # integer
  n_sera, # integer
  n_dim, # integer
  chains = 3, # Number of MCMC chains to run
  cores = parallel::detectCores(logical = F), # For the cluster
  ...
) {
  library(rstan)
  
  stopifnot(nrow(observed_distances) == n_antigens)
  stopifnot(ncol(observed_distances) == n_sera)
  
  model <- stan_model('MDS.stan')
  
  model_input_data <- list(
    n_strains = n_antigens,
    n_sera = n_sera,
    n_dim = n_dim,
    observed_distances = observed_distances
  )
  
  fit <- sampling(
    model, model_input_data, chains = chains, cores = cores, 
    init = initfun,
    iter = 5000,
  #  control = list(adapt_delta = 0.8,
  #                  max_treedepth = 13),
    ...
  )
}

```

```{r}
fits <- fit_stan_MDS(observed_distances = distmat, 
                     n_antigens = n_antigens, 
                     n_sera = n_sera, 
                     n_dim = n_dim, 
                     chains = 1)
```

## Visualize trace plots
```{r}
rstan::traceplot(fits, pars = names(fits))
```

## Visualize the pairs plots
```{r}
pairs(fits, pars = names(fits)[1:5])
```

## Check the distance matrix
```{r}
raw_fits <- rstan::extract(fits)

long_antigen_coords <- lapply(1:n_antigens, function(ll) raw_fits$antigen_coords[,ll,] %>%
                                                      magrittr::set_colnames(c('c1', 'c2')) %>%
                           as.tibble() %>%
                           mutate(id = ll,
                                  iter = 1:nrow(.),
                                  kind = 'antigen')) %>%
                    bind_rows()

long_serum_coords <- lapply(1:n_sera, function(ll) raw_fits$serum_coords[,ll,] %>%
                                                      magrittr::set_colnames(c('c1', 'c2')) %>%
                           as.tibble() %>%
                           mutate(id = ll,
                                  iter = 1:nrow(.),
                                  kind = 'serum')) %>%
                    bind_rows()

summary_coords <- bind_rows(long_antigen_coords,
          long_serum_coords) %>%
  group_by(id, kind) %>%
  summarise(c1.10 = quantile(c1, .1),
            c1 = median(c1),
            c1.90 = quantile(c1, .9),
            c2.10 = quantile(c2, .1),
            c2 = median(c2),
            c2.90 = quantile(c2, .9)) %>%
  ungroup()
```

## Plot
```{r}
cowplot::plot_grid(
summary_coords %>%
  ggplot() +
  geom_point(aes(x = c1, y = c2, color = kind)) +
  ggtitle('stan') +
  theme(legend.position = 'none'),
original_coord_plot +
  ggtitle('original') +
  theme(legend.position = 'none')
)
```
 
 Ok, this looks reasonable, but the MDS coords are shifted like crazy.

## Get the distance matrix and compare to the original.
## If the distances are reasonable, then the inference could be working.
```{r}
cat('Inferred distances (median):\n')
get_ab_ag_distances(ab_coords = summary_coords %>% filter(kind == 'serum') %>% select(matches('c\\d$')) %>% as.matrix(), 
                    ag_coords = summary_coords %>% filter(kind == 'antigen') %>% select(matches('c\\d$')) %>% as.matrix()
)

cat('\nActual distances:\n')
distmat
```


## Ok, this is working, but I think it makes sense to fix the first ag coordinate, and the direction of vec(ag_1, ag_2) so that we don't have to wory about the isometry issue so much.